#' @param x List of networks
#' @param x_ref A single object of class `network` that provides the reference
#' values.
#' @param attr_type Type of attribute to replicate
#' @param attr_name Character vector of the attributes to replicate
#' @noRd
replicate_attr <- function(x, x_ref, attr_type, attr_name) {

  # Basic check
  if (!(attr_type %in% c("vertex", "edge", "network")))
    stop(
      "The -type- of network attribute \"", attr_type, "\" does not exist. ",
      "The only valid types are: \"vertex\", \"edge\", and \"network\".",
      call. = FALSE
      )
    
  # Getting the functions
  getter <- getFromNamespace(
    sprintf("get.%s.attribute", attr_type),
    ns = getNamespace("network")
    )
  
  setter <- getFromNamespace(
    sprintf("set.%s.attribute", attr_type),
    ns = getNamespace("network")
  )
  
  # Looping through the values
  for (a in seq_along(attr_name)) {
    
    # Getting the reference value
    value. <- getter(x_ref, attrname = attr_name[[a]])
    
    # Looping through the networks in x
    for (i in seq_along(x)) 
      setter(
        x        = x[[i]],
        attrname = attr_name[[a]],
        value    = value.
        )
  }
    
  x
}


#' Generate an ergmito model
#' @param object Either a model or an object of class [ergmito].
#' @param theta passed
#' @param ... Passed to [ergmito_formulae()].
#' @export
new_rergmito2 <- function(model, theta, ...) UseMethod("new_rergmito2")

#' @export
new_rergmito2.formula <- function(
  model, 
  theta,
  ...,
  env = parent.frame()
) {
  
  # Part 1: Get the list of networks -------------------------------------------
  LHS <- eval(model[[2]], envir = env)
  
  # If we have more than one graph, se recycle the formulae object (so they have
  # a shared model) but each object will have its own sampler.
  if (nnets(LHS) > 1L) {
    
    model.              <- stats::update.formula(model, LHS[[i]] ~ .)
    environment(model.) <- environment()
    ans <- vector("list", nnets(LHS))
    for (i in seq_along(ans))
      ans[[i]] <- do.call(
        new_rergmito2,
        c(list(model = model., env = environment()), list(...))
        )
    
    return(ans)
    
  }
  
  # Initializing the object
  sampler <- new.env()
  
  # Part 2: Generate the model -------------------------------------------------
  sampler$formulae <- ergmito_formulae(model = model, env = env, ...)
  
  # This is a basic check
  if (length(theta) != sampler$formulae$npars)
    stop(
      sprintf(
        paste(
          "The length of -theta- (%i) does not match the",
          "number of parameters in the model (%i)."
        ),
        length(theta),
        sampler$formulae$npars
      ),
      call. = FALSE
      )
  
  # Part 3: Generating the powerset and adjusting for attributes ---------------
  sampler$networks <- powerset(nvertex(LHS), directed = is_directed(LHS))
  
  # Part 4: Counting the attributes on the powerset ----------------------------
  
  if (!is_directed(LHS) | !all(sampler$formulae$term_fun %in% AVAILABLE_STATS()) | (Sys.getenv("ERGMITO_TEST") != "")) {
    
    # We will need to check whether the model has attributes or not. For now, if
    # the user specified a model update, we assume that the model includes
    # attributes since these could be graph level attributes that are harder to
    # capture.
    if (nrow(sampler$formulae$vertex_attrs) | ( ("model_update" %in% names(list(...))) )) {
      
      # Turning into network class objects
      sampler$networks <- matrix_to_network(sampler$networks, directed = is_directed(LHS))
      
      # Passing the vertex and edge attributes
      sampler$networks <- replicate_attr(
        sampler$networks,
        x_ref     = LHS,
        attr_type = "vertex",
        attr_name = subset(sampler$formulae$vertex_attrs, type == "vertex")$attr
      )
      
      sampler$networks <- replicate_attr(
        sampler$networks,
        x_ref     = LHS,
        attr_type = "edge",
        attr_name = subset(sampler$formulae$vertex_attrs, type == "edge")$attr
      )
      
      # Network attributes (just in case)
      nattrs <- network::list.network.attributes(LHS)
      
      sampler$networks <- replicate_attr(
        sampler$networks,
        x_ref     = LHS,
        attr_type = "network",
        attr_name = nattrs
      )
      
    }
    
    # We now calculate all the statisics
    model_str <- deparse(stats::update.formula(model, p. ~ .))
    sampler$counts <- sapply(pset, function(p.) {
      ergm::summary_formula(as.formula(model_str))
    })
    
  } else {
    
    # Preparing counters
    attrs2pass <- NULL
    if (nrow(sampler$formulae$used_attrs)) {
      
      # Listing what are the attributes to be passed
      attrs2pass <- lapply( 
        X = sampler$formulae$term_attrs,
        function(a.) {
          
          if (!length(a.))
            return(double(0L))
          
          a. <- a.[names(a.) == "vertex"]
          
          if (!length(a.))
            return(double(0L))
          else if (length(a.) > 1L)
            stop(
              "For now, terms with more than one attribute are not supported on. ",
              "The current model you are trying to fit uses the following attributes ",
              "for a single term: ", a., call. = FALSE
            )
          
          network::get.vertex.attribute(LHS, a.[names(a.) == "vertex"])
      })
    } else {
      attrs2pass <- replicate(
        n        = length(sampler$formulae$term_attrs),
        expr     = double(0L),
        simplify = FALSE
        )
    }
    
    sampler$counts <- matrix(
      0, ncol = length(sampler$formulae$term_fun), nrow = length(sampler$networks)
      ) 
    for (k in seq_along(formulae$term_fun))
      sampler$counts[, k] <- count_stats(
        X     = sampler$networks,
        terms = sampler$formulae$term_fun[k],
        attrs = list(attrs2pass[[k]])
      )
    
    
  }
  
  # Making sure we have the names
  colnames(sampler$counts) <- names(ergm::summary_formula(model))
  
  # Figuring out
  # Are we updating the model? ------------------------------------------------
  graph_attrs <- graph_attributes_as_df(LHS)
  model_frame <- model_frame_ergmito(
    formula        = model,
    formula_update = sampler$formulae$model_update, 
    data           = sampler$counts,
    g_attrs.       = graph_attrs
  )
  
  sampler$counts        <- model_frame$stats
  sampler$target_offset <- model_frame$offsets
  
  # Part 5: Functions to sample, re-compute, and subset ------------------------
  sampler$probabilities <- NULL
  
  sampler$calc_probabilities <- function(theta. = NULL) {
    
    sampler$probabilities <- exact_loglik(
      x             = sampler$counts,
      params        = if (is.null(theta.)) theta else theta.,
      stats_weights = sampler$formulae$stats_weights,
      stats_statmat = sampler$formulae$stats_statmat,
      target_offset = sampler$target_offset,
      stats_offset  = sampler$formulae$stats_offset,
      as_prob       = TRUE
      )
    
    invisible()
    
  }
  
  sampler$calc_probabilities()
  
  # A getter function ----------------------------------------------------------
  sampler$get_networks <- function(idx) {
    
    nets <- sampler$networks[idx]
    
    if (sampler_w_attributes) {
      nets <- matrix_to_network(nets)
      replicate_vertex_attr(
        nets,
        attrname = ergm_model$attrnames,
        value    = ergm_model$attrs
      ) 
    } else
      nets
    
  }
  
  # Sampling functions ---------------------------------------------------------
  sampler$sample <- function(n, theta = NULL, as_indexes = FALSE) {
    
    # If no new set of parameters is used, then 
    if (length(theta)) {
      oldp <- sampler$probabilities
      sampler$calc_probabilities(theta)
      on.exit(sampler$probabilities <- oldp)
    } 
    
    idx <- sample.int(
      n       = length(sampler$probabilities),
      size    = n,
      replace = TRUE,
      prob    = sampler$probabilities,
      useHash = FALSE
    )
    
    if (!as_indexes) 
      sampler$get_networks(idx)
    else 
      idx
    
  }
  
  # Call
  sampler$call     <- match.call()
  sampler$network  <- LHS

  structure(
    sampler,
    class = "ergmito_sampler"
  )
  
}

#' @export
#' @rdname new_rergmito
#' @param i,j `i` is an integer vector indicating the indexes of the networks to
#' draw, while `j` the corresponding sizes. These need not to be of the same size.
#' @details The indexing method, `[.ergmito_sampler`, allows extracting networks
#' directly by passing indexes. `i` indicates the index of the networks to draw,
#' which go from 1 through `2^(n*(n-1))`, and `j` indicates the requested
#' size. 
#' @return The indexing method `[.ergmito_sampler` returns a named list of length
#' `length(j)`.
`[.ergmito_sampler` <- function(x, i, j, ...) {
  
  # Checking sizes
  j <- as.character(j)
  test <- which(!(j %in% as.character(x$sizes)))
  if (length(test))
    stop(
      "Some values of `j` (requested sizes) are not included in the sampling function: ",
      paste(j[test], collapse = ", "), ".", call. = FALSE
    )
  
  # Sampling networks
  ans <- structure(vector("list", length(j)), names = j)
  for (k in j)
    ans[[j]] <- x$get_networks(i, k)
  
  return(ans)
  
}

#' @export
print.ergmito_sampler <- function(x, ...) {
  
  cat("ERGMito simulator\n")
  cat("Call   :", deparse(x$call), "\n")
  cat("sample :", deparse(x$sample)[1], "\n")
  
  invisible(x)
  
}

#' @export
#' @importFrom utils ls.str
str.ergmito_sampler <- function(object, ...) {
  
  utils::ls.str(object, ...)
  
}
