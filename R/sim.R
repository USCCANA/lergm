#' ERGMito sampler
#' 
#' Using 
#' 
#' @param model A formula.
#' @param theta Named vector. Model parameters.
#' @param x An object of class `ergmito_sampler`.
#' @param sizes Integer vector. Values between 2 to 5 (6 becomes too intensive).
#' @param mc.cores Integer. Passed to [parallel::mclapply]
#' @param ... Further arguments passed to [ergm::ergm.allstats].
#' 
#' @return An environment with the following objects:
#' 
#' - `calc_prob`
#' - `call`
#' - `counts`
#' - `networks`
#' - `prob`
#' - `sample` A function to draw samples. `n` specifies the number of samples to
#'   draw, `s` the size of the networks, and `theta` the parameter to use to
#'   calculate the likelihoods.
#' - `theta`
#' 
#' 
#' 
#' @export
#' @importFrom parallel mclapply
new_rergmito <- function(model, theta = NULL, sizes = NULL, mc.cores = 2L,...) {
  
  # environment(model) <- parent.frame()
  
  # What are the sizes
  if (!length(sizes)) {
    sizes <- nvertex(model)
    sizes <- sort(unique(sizes))
  }
  
  # Getting the estimates
  if (!length(theta))
    theta <- coef(ergmito(model, zeroobs = FALSE))
  
  # Obtaining the network(s) object
  net   <- eval(model[[2]], envir = environment(model))
  terms <- attr(stats::terms(model), "term.labels")
  
  # Checking stats0
  dots <- list(...)
  dots$zeroobs <- FALSE
  
  # Generating powersets
  ans          <- new.env()
  ans$networks <- lapply(sizes, powerset)
  ans$theta    <- theta
  names(ans$networks) <- sizes
  
  # Analyzing formula
  ergm_model       <- analyze_formula(model)
  ergm_model_attrs <- which(sapply(ergm_model$attrnames, length) > 0)
  
  # Capturing attributes (if any)
  if (length(ergm_model_attrs) && nnets(net) != 1L) {
    
    stop(
      "Nodal attributes cannot be used when nnets() > 1L and sizes != nvertex().",
      call. = FALSE
      )
    
  } else if (length(ergm_model_attrs) && nnets(net) == 1L) {
    
    for (a in ergm_model_attrs) {
      ergm_model$attrs[[a]] <-
        if (is.null(ergm_model$attrnames[[a]]))
          numeric(0)
      else
        network::get.vertex.attribute(net, attrname = ergm_model$attrnames[[a]])
    }
  }
  
  if (all(ergm_model$names %in% AVAILABLE_STATS()) & Sys.getenv("ERGMITO_TEST") == "") {
    # THE ERGMITO WAY ----------------------------------------------------------
    
    # We will use this updated version
    model. <- stats::update.formula(model, net_i ~ .)
    
    for (s in names(ans$networks)) {
      
      # Generating all statistics
      if (nnets(net) == 1 && nvertex(net) == as.integer(s)) {
        
        net_i <- net
        
      } else if (nnets(net) > 1 && !length(ergm_model_attrs)) {
        
        net_i <- rbernoulli(as.integer(s))
        
      } 
      
      # if (network::is.network(net) || is.matrix(net))
      #   net_i <- net
      # else if (is.list(net))
      #   net_i <- net[[1]]
        
      # Computing all stats
      environment(model.) <- environment()
      S <- do.call(ergm::ergm.allstats, c(list(formula = model.), dots))
      
      # Doing parlapply over the networks. Notice that we split the chunks using
      # splitIndices instead of applying the function directly since count_stats
      # receives lists (so multiple networks at the same time).
      ans$counts[[s]] <- parallel::mclapply(
        X   = parallel::splitIndices(length(ans$networks[[s]]), mc.cores), 
        FUN = function(idx) {
          
          # Making room
          smat <- matrix(ncol = length(ergm_model$names), nrow = length(idx))
          for (j in seq_along(ergm_model$names)) 
            smat[,j] <- count_stats(
                X     = ans$networks[[s]][idx],
                terms = ergm_model$names[j],
                # All individuals have the same data
                attrs = replicate(length(idx), ergm_model$attrs[[j]], simplify = FALSE)
                )
          
          # Returning a single matrix with network statistics
          smat
          
        })
      
      # Adding the results
      ans$counts[[s]] <- do.call(rbind, ans$counts[[s]])
      ans$counts[[s]] <- c(list(stats = ans$counts[[s]]), S)
    }
    
  } else {
    # THE ERGM WAY -------------------------------------------------------------
    
    # Are we addinig attributes?
    if (nnets(net) == 1 && network::is.network(net)) {
      attrs <- list()
      
      vattrs <- network::list.vertex.attributes(net)
      if (length(vattrs)) {
        
        # Getting the attributes
        attrs$vertex.attr      <- lapply(vattrs, network::get.vertex.attribute, x = net)
        attrs$vertex.attrnames <- vattrs
        
        # Adding attributes to the networks
        if (length(ans$neworks) > 1L) {
          warning(
            "When `length(size) > 1`, attributes from the networks in `x` cannont",
            " be added (don't know what goes with what). We will skip adding the",
            " observed attributes to the family of networks. This could result",
            " in an error if the model includes nodal attributes.", call. = FALSE)
        } else {
          
          for (i in seq_along(ans$networks[[1]]))
            ans$networks[[1L]][[i]] <- network::network(
              x                = ans$networks[[1L]][[i]],
              vertex.attr      = attrs$vertex.attr,
              vertex.attrnames = attrs$vertex.attrnames
            )
        }
        
      } else
        attrs <- NULL
    }
    
    for (s in names(ans$networks)) {
      
      # Computing probabilities
      if (nnets(net) == 1 && nvertex(net) == as.integer(s)) {
        
        net_i <- net
        
      } else if (nnets(net) > 1 && !length(ergm_model_attrs)) {
        
        net_i <- rbernoulli(as.integer(s))
        
      } else #if (nnets(net) > 1 && length(ergm_model_attrs)) {
        stop("Nodal attributes cannot be used when nnets() > 1L and sizes != nvertex().",
             call. = FALSE)
      
      model. <- stats::update.formula(model, net_i ~ .)
      environment(model.) <- environment()
      i <- 1L
      S <- do.call(ergm::ergm.allstats, c(list(formula = model.), dots))
      
      # Updating the model (again)
      model. <- stats::update.formula(model, ans$networks[[s]][[i]] ~ .)
      
      ans$counts[[s]] <- parallel::mclapply(
        parallel::splitIndices(length(ans$networks[[s]]), mc.cores),
        function(idx) {
        
        # Getting the corresponding powerset
        stats <- matrix(
          nrow = length(idx),
          ncol = length(terms), dimnames = list(NULL, terms)
          )
        
        # Updating the environment
        environment(model.) <- environment()
        
        # In the first iteration we need to compute the statsmat
        for (i in idx) 
          stats[i, terms] <- summary(model.)
        
        stats
        
      })
      
      ans$counts[[s]] <- do.call(rbind, ans$counts[[s]])
      ans$counts[[s]] <- c(list(stats = ans$counts[[s]]), S)
      
    }

  }
  
  
  # Computing probabilities
  ans$prob <- lapply(sizes, function(s) vector("double", 2^(s*(s-1))))
  names(ans$prob) <- as.character(sizes)
  
  # Function to compute probabilities
  ans$calc_prob <- function(theta = NULL, s = NULL) {
    
    if (!length(s))
      s <- names(ans$prob)
    
    if (!length(theta))
      theta <- ans$theta
    
    for (i in s)
      ans$prob[[i]] <- exp(exact_loglik(
        x       = ans$counts[[i]]$stats,
        params  = theta,
        weights = ans$counts[[i]]$weights,
        statmat = ans$counts[[i]]$statmat
      ))
      
    invisible()
  }
  
  # Calling the prob function
  ans$calc_prob()
  
  # Sampling function
  ans$sample <- function(n, s, theta = NULL) {
    
    s <- as.character(s)
    # All should be able to be sampled
    test <- which(!(s %in% as.character(sizes)))
    if (length(test))
      stop("Some values of `s` are not included in the sampling function.",
           call. = FALSE)
    
    # If no new set of parameters is used, then 
    if (length(theta)) {
      oldp <- ans$prob[s]
      ans$calc_prob(theta, s)
      on.exit(ans$prob[s] <- oldp)
    } 
    
    ans$networks[[s]][
      sample.int(
        n       = length(ans$prob[[s]]),
        size    = n,
        replace = TRUE,
        prob    = ans$prob[[s]],
        useHash = FALSE
        )
      ]
      
  }
  
  # Call
  ans$call <- match.call()
  ans$network0 <- net
  ans$sizes    <- nvertex(net)
  
  structure(
    ans,
    class = "ergmito_sampler"
  )
  
}

#' @export
#' @rdname new_rergmito
print.ergmito_sampler <- function(x, ...) {
  
  cat("ERGMito simulator\n")
  cat("Call   :", deparse(x$call), "\n")
  cat("sample :", deparse(x$sample)[1], "\n")
  
  invisible(x)
  
}

#' @export
#' @importFrom utils ls.str
str.ergmito_sampler <- function(object, ...) {
  
  utils::ls.str(object, ...)
  
}
