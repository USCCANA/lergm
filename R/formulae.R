
#' Processing formulas in `ergmito`
#' 
#' The ERGMitos R package allows estimating pooled ERGMs by aggregating
#' independent networks together. 
#' 
#' @param model A formula. The left-hand-side can be either a small network, or
#' a list of networks. 
#' @param gattr_model A formula. Model especification for graph attributes. This
#' is useful when using multiple networks.
#' @param stats A list.
#' @param target.stats Observed statistics. If multiple networks, then a list, otherwise
#' a named vector (see [ergm::summary_formula]). 
#' @param ... Further arguments passed to [ergm::ergm.allstats].
#' @param env Environment in which `model` should be evaluated.
#' @return A list of class `ergmito_loglik`.
#' 
#' - `loglik` A function. The log-likelihood function.
#' - `grad` A function. The gradient of the model.
#' - `stats` If the number of networks is greater than 1, then a list of objects
#' as returned by [ergm::ergm.allstats] (one per network). Otherwise, a single
#' list returned by the same function.
#' - `model` A formula. The model passed.
#' - `npars` Integer. Number of parameters.
#' - `nnets` Integer. Number of networks to estiamte.
#' 
#' @export
ergmito_formulae <- function(
  model,
  gattr_model  = NULL,
  target.stats = NULL,
  stats        = NULL,
  env          = parent.frame(),
  ...
  ) {
  
  # Collecting extra options
  dots <- list(...)
  if (!length(dots$zeroobs))
    dots$zeroobs <- FALSE

  # Capturing model
  if (!inherits(model, "formula"))
    model <- eval(model, envir = env)
  
  # What is the first component
  LHS <- eval(model[[2]], envir = env)
  
  # Checking the appropriate types
  if (inherits(LHS, "list")) {
    
    # Are all either matrices or networks?
    test <- which(!(sapply(LHS, class) %in% c("matrix", "network")))
    if (length(test))
      stop("One of the components is not a matrix `", deparse(model[[2]]),
         "` is of class ", class(LHS), ".", call. = FALSE)
    
  } else if (inherits(LHS, "matrix") | inherits(LHS, "network")) {
    
    # Nesting into a list. Later we will loop over the elements, so we can
    # apply the same logic regardless of if it is one or more networks
    LHS <- list(LHS)
    
  } else
    stop("LHS of the formula should be either a list of networks or a single ",
         "network.", call. = FALSE)
  
  # We will evaluate the formula in the current environment
  model. <- model
  model. <- stats::update.formula(model., LHS[[i]] ~ .)
  
  formulaeenv <- environment()
  environment(model.) <- formulaeenv
  
  # Checking observed stats and stats
  if (!length(stats))
    stats <- vector("list", nnets(LHS))
  
  # Has the user passed target statistics?
  if (!length(target.stats))
    target.stats <- vector("list", nnets(LHS))
  else # This is painful, the current way I have this written needs me to pass
       # the target.stats as a list instead of a matrix, which is not the best.
       # For now it should be OK.
    target.stats <- lapply(1:nrow(target.stats), function(i) target.stats[i,])
  
  # Need to improve the speed of this!
  for (i in 1L:nnets(LHS)) {
    # Calculating gattrs_model
    
    if (length(gattr_model))
      g <- gmodel(gattr_model, LHS[[i]])[1,]
    else
      g <- NULL
    
    # Calculating observed statistics
    if (!length(target.stats[[i]]))
      target.stats[[i]] <- c(summary(model.), g)
    
    # Should it be normalized to 0?
    if (length(dots$zeroobs) && dots$zeroobs)
      target.stats[[i]][] <- rep(0, length(target.stats[[i]][]))
    
    # Calculating statistics and weights
    if (!length(stats[[i]]))
      stats[[i]] <- do.call(ergm::ergm.allstats, c(list(formula = model.), dots))
    
    # Adding graph parameters to the statmat
    if (length(g)) {
      stats[[i]]$statmat <- cbind(
        stats[[i]]$statmat,
        matrix(
          target.stats[[i]][names(g)], nrow = nrow(stats[[i]]$statmat), ncol=length(g),
          byrow = TRUE, dimnames = list(NULL, names(g))
          )
        )
    }
    
  }
  
  # Coercing objects
  target.stats   <- do.call(rbind, target.stats)
  weights <- lapply(stats, "[[", "weights")
  statmat <- lapply(stats, "[[", "statmat")
  
  structure(list(
    loglik = function(params, stats = NULL, target.stats = NULL) {
      
      # If no target.stats specified, used the observed in the data
      if (is.null(target.stats))
        target.stats <- formulaeenv$target.stats
      
      # Are we including anything 
      ans <- if (!length(stats)) {
        exact_loglik(
          params = params, x = target.stats,
          weights = formulaeenv$weights, statmat = formulaeenv$statmat
        )
      } else {
        exact_loglik(
          params = params, x = target.stats,
          weights = stats$weights, statmat = stats$statmat
        )
      }
      
      ans <- sum(ans)
      
      # If awfully undefined
      if (!is.finite(ans))
        return(sign(ans) * .Machine$double.xmax * 1e-100)
      else
        return(ans)
      # max(ans, -.Machine$double.xmax/1e100)
      
    },
    grad  = function(params, stats = NULL, target.stats = NULL) {
      
      # If no target.stats specified, used the observed in the data
      if (is.null(target.stats))
        target.stats <- formulaeenv$target.stats
      
      # Are we including anything 
      ans <- if (!length(stats)) {
        exact_gradient(
          params = params, x = target.stats,
          weights = formulaeenv$weights, statmat = formulaeenv$statmat
        )
      } else {
        exact_gradient(
          params = params, x = target.stats,
          weights = stats$weights, statmat = stats$statmat
        )
      }
      
      # If awfully undefined
      # if (is.nan(ans))
      #   return(-.Machine$double.xmax/1e100)
      # 
      # max(ans, -.Machine$double.xmax/1e100)
      
      # ans[is.nan(ans)] <- .Machine$double.xmax/1e100
      
      test <- which(is.infinite(ans))
      if (length(test))
        ans[test] <- sign(ans[test])*.Machine$double.xmax/1e100
      
      ans
      
    },
    target.stats = target.stats,
    stats        = stats,
    model        = stats::as.formula(model, env = env),
    npars        = ncol(target.stats),
    nnets        = nnets(LHS)
  ), class="ergmito_loglik")
  
  
  
}

gmodel <- function(model, net) {
  
  netattrs <- network::list.network.attributes(net)
  ans <- lapply(netattrs, network::get.network.attribute, x = net)
  names(ans) <- netattrs
    
  stats::model.matrix(
    stats::update.formula(model, ~ 0 + .),
    as.data.frame(ans)
    )
  
  
}

#' @export
print.ergmito_loglik <- function(x, ...) {
  
  cat("ergmito log-likelihood function\n")
  cat("Number of networks: ", x$nnets, "\n")
  cat("Model: ", deparse(x$model), "\n")
  cat("Available elements by using the $ operator:\n")
  cat(sprintf("loglik: %s", deparse(x$loglik)[1]))
  cat(sprintf("grad  : %s", deparse(x$grad)[1]))
  
  invisible(x)
}

#' Vectorized calculation of ERGM exact loglikelihood
#' 
#' This function can be compared to [ergm::ergm.exact] with the statistics
#' centered at `x`, the observed statistic.
#' 
#' @param x Matrix. Observed statistics
#' @param params Numeric vector. Parameter values of the model.
#' @param weights,statmat Vector and Matrix as returned by [ergm::ergm.allstats].
#' @export
exact_loglik <- function(x, params, weights, statmat) {
  
  # Need to calculate it using chunks of size 200, otherwise it doesn't work(?)
  chunks <- make_chunks(nrow(x), 4e5)
  
  n <- nrow(x)
  
  # Checking the weights and stats mat
  if (n == 1) {
    # If only one observation
    
    if (!is.list(weights))
      weights <- list(weights)
    
    if (!is.list(statmat))
      statmat <- list(statmat)
    
  } else if (n > 1) {
    # If more than 1, then perhaps we need to recycle the values
    
    if (!is.list(weights)) {
      weights <- list(weights)
    } else if (length(weights) != n) {
      stop("length(weights) != nrow(x). When class(weights) == 'list', the number",
           " of elements should match the number of rows in statistics (x).", 
           call. = FALSE)
    }
    
    if (!is.list(statmat)) {
      statmat <- list(statmat)
    } else if (length(statmat) != n) {
      stop("length(statmat) != nrow(x). When class(statmat) == 'list', the number",
           " of elements should match the number of rows in statistics (x).", 
           call. = FALSE)
    }
    
  } else 
    stop("nrow(x) == 0. There are no observed statistics.", call. = FALSE)
  

  # Computing in chunks
  ans <- vector("double", n)
  if (length(weights) > 1L) {
    for (s in seq_along(chunks$from)) {
      
      i <- chunks$from[s]
      j <- chunks$to[s]
      
      ans[i:j] <- exact_loglik.(x[i:j, ,drop=FALSE], params, weights[i:j], statmat[i:j])
      
    }
  } else {
    for (s in seq_along(chunks$from)) {
      
      i <- chunks$from[s]
      j <- chunks$to[s]
      
      ans[i:j] <- exact_loglik.(x[i:j, ,drop=FALSE], params, weights, statmat)
      
    }
  }
  
  ans
  
}

# This function uis just used for testing
exact_loglik2 <- function(params, stat0, stats) {
  
  sum(params * stat0) - log(stats$weights %*% exp(stats$statmat %*% params))
  
}

#' @rdname exact_loglik
#' @export
exact_gradient <- function(x, params, weights, statmat) {
  
  # Need to calculate it using chunks of size 200, otherwise it doesn't work(?)
  chunks <- make_chunks(nrow(x), 4e5)
  
  n <- nrow(x)
  
  # Checking the weights and stats mat
  if (n == 1) {
    # If only one observation
    
    if (!is.list(weights))
      weights <- list(weights)
    
    if (!is.list(statmat))
      statmat <- list(statmat)
    
  } else if (n > 1) {
    # If more than 1, then perhaps we need to recycle the values
    
    if (!is.list(weights)) {
      weights <- list(weights)
    } else if (length(weights) != n) {
      stop("length(weights) != nrow(x). When class(weights) == 'list', the number",
           " of elements should match the number of rows in statistics (x).", 
           call. = FALSE)
    }
    
    if (!is.list(statmat)) {
      statmat <- list(statmat)
    } else if (length(statmat) != n) {
      stop("length(statmat) != nrow(x). When class(statmat) == 'list', the number",
           " of elements should match the number of rows in statistics (x).", 
           call. = FALSE)
    }
    
  } else 
    stop("nrow(x) == 0. There are no observed statistics.", call. = FALSE)
  
  
  # Computing in chunks
  ans <- matrix(0, nrow = length(params), ncol=1L)
  for (s in seq_along(chunks$from)) {
    
    i <- chunks$from[s]
    j <- chunks$to[s]
    
    ans <- ans + exact_gradient.(x[i:j, ,drop=FALSE], params, weights[i:j], statmat[i:j])
    
  }
  
  ans
  
}

exact_loglik_gr <- function(params, stat0, stats) {
  
  exp_sum  <- exp(stats$statmat %*% params)
  
  stat0 - 
    1/log(stats$weights %*% exp_sum)[1]*(t(stats$statmat) %*% (exp_sum*stats$weights))
  
  
}

