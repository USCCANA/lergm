% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ergmito.R
\name{ergmito}
\alias{ergmito}
\alias{print.ergmito}
\alias{summary.ergmito}
\alias{print.ergmito_summary}
\alias{coef.ergmito}
\alias{logLik.ergmito}
\alias{nobs.ergmito}
\alias{vcov.ergmito}
\alias{formula.ergmito}
\title{Estimation of ERGMs using Exact likelihood functions}
\usage{
ergmito(model, gattr_model = NULL, stats.weights = NULL,
  stats.statmat = NULL, optim.args = list(), init = NULL,
  use.grad = TRUE, target.stats = NULL, ...)

\method{print}{ergmito}(x, ...)

\method{summary}{ergmito}(object, ...)

\method{print}{ergmito_summary}(x, ...)

\method{coef}{ergmito}(object, ...)

\method{logLik}{ergmito}(object, ...)

\method{nobs}{ergmito}(object, ...)

\method{vcov}{ergmito}(object, solver = NULL, ...)

\method{formula}{ergmito}(x, ...)
}
\arguments{
\item{model}{Model to estimate. See \link[ergm:ergm]{ergm::ergm}. The only difference with
\code{ergm} is that the LHS can be a list of networks.}

\item{gattr_model}{A formula. Model especification for graph attributes. This
is useful when using multiple networks.}

\item{stats.weights, stats.statmat}{Lists as returned by \link[ergm:ergm.allstats]{ergm::ergm.allstats}.
When this is provided, the function does not call \code{ergm.allstats}, which can
be useful in simulations.}

\item{optim.args}{List. Passed to \link[stats:optim]{stats::optim}.}

\item{init}{A numeric vector. Sets the starting parameters for the
optimization routine. Default is a vector of zeros.}

\item{use.grad}{Logical. When \code{TRUE} passes the gradient function to \code{optim}.
This is intended for testing only (internal use).}

\item{target.stats}{A matrix of target statistics (see \link[ergm:ergm]{ergm::ergm}).}

\item{...}{Further arguments passed to the method. In the case of \code{ergmito},
\code{...} are passed to \link{ergmito_formulae}.}

\item{x, object}{An object of class \code{ergmito}}

\item{solver}{Function. Used to compute the inverse of the hessian matrix. When
not null, the variance-covariance matrix is recomputed using that function.
By default, \code{ergmito} uses \link[MASS:ginv]{MASS::ginv}.}
}
\value{
An list of class \code{ergmito}:
\itemize{
\item \code{call}          The program call.
\item \code{coef}          Named vector. Parameter estimates.
\item \code{iterations}    Integer. Number of times the loglikelihood was evaluated
(see \link[stats:optim]{stats::optim}).
\item \code{loglikelihood} Numeric. Final value of the objective function.
\item \code{covar}         Square matrix of size \code{length(coef)}. Variance-covariance matrix
\item \code{coef.init}     Named vector of length \code{length(coef)}. Initial set of parameters
used in the optimization.
\item \code{formulae}      An object of class \link[=ergmito_formulae]{ergmito_loglik}.
\item \code{network}       Networks passed via \code{model}.
\item \code{status},\code{note} Convergence code. See \link{check_convergence}
}
}
\description{
As a difference from \link[=ergm]{ergm::ergm}, \code{ergmito} uses the exact log-likelihood
function for fitting the model. This implies that all the \code{2^(n*(n-1))}
graphs are generated for computing the normalizing constant of the ERGM
model. This implies that models with up to 5 nodes are relatively simple
to fit, since more than that can become infeasible.
}
\section{MLE}{


Maximum Likelihood Estimates are obtained using the \link[stats:optim]{stats::optim} function.
The default method for maximization is \code{BFGS} using both the loglikelihood
function and its corresponding gradient.

Another important factor to consider is the existance of the MLE estiates.
As shown in Handcock (2003), if the observed statitcs are near the border
if the support function (e.g. too many edges or almost none), then, even if
the MLE estimates exists, the optimization function may not be able to reach
the optima. Moreover, if the target (observed) statistics live in the boundary,
then the MLE estimates do not exists. In general, this should not be an issue
in the context of the pooled model, as the variability of observed statistics
should be enough to avoid those situations.

The function \code{ergmito} will try to identify possible cases of non-existance,
of the MLE, and if identified then try to re estimate the model parameters using
larger values than the ones obtained, if the log-likelihood is greater, then it is
assumed that the model is degenerate and the corresponding values will be
replaced with either \code{+Inf} or  \code{-Inf}. By default, this behavior is checked
anytime that the absolute value of the estimates is greater than 5, or the
sufficient statistics were flagged as potentially outside of the interior of
the support (close to zero or to its max).
}

\examples{

# Generating a small graph
set.seed(12)
n <- 4
net <- rbernoulli(n, p = .7)

model <- net ~ edges + mutual

library(ergm)
ans_ergmito <- ergmito(model)
ans_ergm  <- ergm(model)

# The ergmito should have a larger value
ergm.exact(ans_ergmito$coef, model)
ergm.exact(ans_ergm$coef, model)

summary(ans_ergmito)
summary(ans_ergm)

# Example 2: Estimating an ERGMito using data with know DGP parameters -----
data(fivenets) 

model1 <- ergmito(fivenets ~ edges + nodematch("female"))
summary(model1) # This data has know parameters equal to -2.0 and 2.0

\dontrun{
# Example 3: Likelihood ratio test using the lmtest R package

library(lmtest)
data(fivenets)
model1 <- ergmito(fivenets ~ edges + nodematch("female"))
model2 <- ergmito(fivenets ~ edges + nodematch("female") + mutual)

lrtest(model1, model2)
# Likelihood ratio test
# 
# Model 1: fivenets ~ edges + nodematch("female") 
# Model 2: fivenets ~ edges + nodematch("female") + mutual
#   #Df  LogLik Df  Chisq Pr(>Chisq)
# 1   2 -34.671                     
# 2   3 -34.205 1 0.9312     0.3346

}

}
\seealso{
The function \link{plot.ergmito} for post-estimation diagnostics.
}
